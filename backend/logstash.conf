# Logstash Configuration for Kaleidoscope Multi-Service Logging
# Version 3.3: Fixed syntax errors and improvements

# ==============================================================================
# INPUTS
# ==============================================================================
input {
  tcp {
    port => 5000
    codec => json_lines
    tags => ["java-backend"]
  }
  tcp {
    port => 5001
    codec => json_lines
    tags => ["python-ml"]
  }
  http {
    port => 5002
    tags => ["http-source"]
  }
  beats {
    port => 5044
    tags => ["beats-source"]
  }
}

# ==============================================================================
# FILTER
# ==============================================================================
filter {
  # --- Step 1: Basic Structuring ---
  # Set index prefix based on service field
  if [service] {
    mutate {
      add_field => { "[@metadata][index_prefix]" => "%{service}" }
    }
  } else {
    mutate {
      add_field => { "[@metadata][index_prefix]" => "kaleidoscope-unknown" }
    }
  }

  # --- Step 2: Promote Key Fields from MDC ---
  if [mdc] {
    # Only add fields if they exist in MDC to avoid null values
    if [mdc][correlationId] {
      mutate { add_field => { "correlation_id" => "%{[mdc][correlationId]}" } }
    }
    if [mdc][requestMethod] {
      mutate { add_field => { "request_method" => "%{[mdc][requestMethod]}" } }
    }
    if [mdc][requestUri] {
      mutate { add_field => { "request_uri" => "%{[mdc][requestUri]}" } }
    }
    if [mdc][responseStatus] {
      mutate { add_field => { "response_status" => "%{[mdc][responseStatus]}" } }
    }
    if [mdc][responseTimeMs] {
      mutate { add_field => { "response_time_ms" => "%{[mdc][responseTimeMs]}" } }
    }
    if [mdc][clientIp] {
      mutate { add_field => { "client_ip" => "%{[mdc][clientIp]}" } }
    }
    if [mdc][userAgent] {
      mutate { add_field => { "user_agent_original" => "%{[mdc][userAgent]}" } }
    }
  }

  # --- Step 3: Data Type Conversion ---
  if [response_status] {
    mutate {
      convert => { "response_status" => "integer" }
    }
  }
  if [response_time_ms] {
    mutate {
      convert => { "response_time_ms" => "integer" }
    }
  }

  # --- Step 4: External Data Enrichment ---
  # GeoIP enrichment for external IPs only
  if [client_ip] and [client_ip] !~ /^(127\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/ {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # User agent parsing
  if [user_agent_original] {
    useragent {
      source => "user_agent_original"
      target => "user_agent"
    }
  }

  # --- Step 5: Categorization based on Content ---
  # API categorization
  if [request_uri] {
    if [request_uri] =~ /\/api\/auth/ {
      mutate { add_field => { "api_category" => "authentication" } }
    } else if [request_uri] =~ /\/api\/users/ {
      mutate { add_field => { "api_category" => "user_management" } }
    } else if [request_uri] =~ /\/api\/posts/ {
      mutate { add_field => { "api_category" => "content_management" } }
    } else if [request_uri] =~ /\/actuator/ {
      mutate { add_field => { "api_category" => "monitoring" } }
    } else {
      mutate { add_field => { "api_category" => "other" } }
    }
  }

  # Performance categorization
  if [response_time_ms] {
    if [response_time_ms] >= 1000 {
      mutate { add_field => { "performance_category" => "very_slow" } }
    } else if [response_time_ms] >= 500 {
      mutate { add_field => { "performance_category" => "slow" } }
    } else if [response_time_ms] >= 100 {
      mutate { add_field => { "performance_category" => "normal" } }
    } else {
      mutate { add_field => { "performance_category" => "fast" } }
    }
  }

  # Status categorization
  if [response_status] {
    if [response_status] >= 500 {
      mutate { add_field => { "status_category" => "server_error" } }
    } else if [response_status] >= 400 {
      mutate { add_field => { "status_category" => "client_error" } }
    } else if [response_status] >= 300 {
      mutate { add_field => { "status_category" => "redirect" } }
    } else if [response_status] >= 200 {
      mutate { add_field => { "status_category" => "success" } }
    }
  }

  # --- Step 6: Timestamp and Security ---
  # Add time-based fields
  ruby {
    code => "
      timestamp = event.get('@timestamp')
      if timestamp
        event.set('hour_of_day', timestamp.time.hour)
        event.set('day_of_week', timestamp.time.strftime('%A'))
      end
    "
  }

  # Security detection
  if [request_uri] {
    if [request_uri] =~ /\.\./ or [request_uri] =~ /<script/ or [request_uri] =~ /javascript:/ or [request_uri] =~ /eval\(/ or [request_uri] =~ /(?i)union.*select/ {
      mutate {
        add_tag => ["security_incident"]
        add_field => { "security_alert" => "potential_attack_detected" }
      }
    }
  }

  # Bot detection
  if [user_agent_original] {
    if [user_agent_original] =~ /(?i)(bot|crawler|spider|scraper)/ {
      mutate {
        add_tag => ["bot_traffic"]
        add_field => { "request_type" => "bot" }
      }
    } else {
      mutate {
        add_field => { "request_type" => "human" }
      }
    }
  }

  # --- Step 7: Final Cleanup ---
  # Remove intermediate fields
  mutate {
    remove_field => ["mdc"]
  }
}

# ==============================================================================
# OUTPUTS
# ==============================================================================
output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "%{[@metadata][index_prefix]}-%{+yyyy.MM.dd}"
    manage_template => true
  }

  # Optional: Remove or comment out stdout for production
  # stdout {
  #   codec => rubydebug
  # }
}